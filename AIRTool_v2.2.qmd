---
title: "AIRTOOL PROTOTYPE--not intended for public consumption"
format: 
  dashboard:
    theme: lumen
    orientation: columns
    # embed-resources: true
server: shiny
---

```{=html}
<style>
  .plot-container, .shiny-text-output, .panel, .card {
    border: none;
    box-shadow: none;
  }
  .custom-text {
    font-size: 20px;
    color: green;
    font-weight: bold;
  }
</style>
```

```{=html}
<style> .main-container { max-width: unset; } </style>
```

```{=html}
<style> .main-container { max-height: unset; } </style>
```

```{r}
#| context: setup
#| echo: false
#| include: false

# suppressMessages(library(tidyverse))
suppressMessages(library(AIPW))
suppressMessages(library(DiagrammeR))
suppressMessages(library(dplyr))
suppressMessages(library(e1071))
suppressMessages(library(earth))
suppressMessages(library(ggplot2))
suppressMessages(library(hal9001))
suppressMessages(library(here))
suppressMessages(library(nnet))
suppressMessages(library(randomForest))
suppressMessages(library(readr))
suppressMessages(library(rJava))
suppressMessages(library(rpart))
suppressMessages(library(scales))
suppressMessages(library(shiny))
suppressMessages(library(shinyWidgets))
suppressMessages(library(sl3))
suppressMessages(library(tidyr))
suppressMessages(library(tmle3))
suppressMessages(library(xgboost))
suppressMessages(library(jsonlite))

AIRHome <- here()
setwd(AIRHome)
set.seed(123)

# Nick, I significantly reduced the complexity of tetrad_utils. Most of what it
# was doing is no longer needed.

source("scripts/AIR_functions.R")
if (!dir.exists(paste0(AIRHome, "/data/"))) {
  dir.create(paste0(AIRHome, "/data/"), recursive = TRUE)
}

if (!dir.exists(paste0(AIRHome, "/input/"))) {
  dir.create(paste0(AIRHome, "/input/"), recursive = TRUE)
}

if (!dir.exists(paste0(AIRHome, "/plots/"))) {
  dir.create(paste0(AIRHome, "/plots/"), recursive = TRUE)
}

if (Sys.info()["sysname"] == "Linux") {
  source("scripts/tetrad_utils.R")
  source("scripts/TetradSearch.R")
  
  if (!dir.exists(paste0(AIRHome, "/data/"))) {
    dir.create(paste0(AIRHome, "/data/"), recursive = TRUE)
  }
  
  if (!dir.exists(paste0(AIRHome, "/input/"))) {
    dir.create(paste0(AIRHome, "/input/"), recursive = TRUE)
  }
  
  if (!dir.exists(paste0(AIRHome, "/plots/"))) {
    dir.create(paste0(AIRHome, "/plots/"), recursive = TRUE)
  }
  # Setup Java and Tetrad
  ## if running on local machine, uncomment out the next line
  # setup_tetrad_environment()
  
  .jinit()
  # .jinit(parameters = "-verbose:class")
  .jaddClassPath(TETRAD_PATH)
  
  java_version <- .jcall("java/lang/System", "S", "getProperty", "java.version")
  # print(paste("Java version:", java_version))

  } 
```

# Setup

##  {.sidebar}

```{r}
h4("Step 1: Upload your data")
fileInput("file1", "", accept = ".csv")
br()
uiOutput('step2')
uiOutput('ui_file2')
br()
uiOutput('ui_buildButton')
br()
uiOutput('step3')
uiOutput('xvar')
uiOutput('ui_threshold_x')
br()
uiOutput('yvar')
uiOutput('ui_threshold_y')
br()
uiOutput('ui_updateButton')
uiOutput('step4')
uiOutput('ui_model_exist')
uiOutput('ui_model_upload')
uiOutput('ui_ate_upload')
uiOutput('ui_goButton')

```

## Column {width = "40%"}

```{r}
grVizOutput('blankGraph')
```

## Column {width = "60%"}

```{r}
plotOutput('histogram_x', height = "50%")
```

#### Row

```{r}
plotOutput('histogram_y', height = "50%")
```

# Results

## Column {width="60%"}

```{r}
#| padding: 0px
##| title: "Causal Discovery"
uiOutput('ui_graphViz')
```

## Column {width="40%"}

```{r}
#| padding: 0px
# UI Output for ribbon plot
uiOutput("second_column_content")
```

```{r}
#| context: server

calc_complete <- reactiveVal(FALSE)
graph_complete <- reactiveVal(FALSE)
graph_update <- reactiveVal(FALSE)

model_in <- reactive({
  req(input$model_in)
  #loading the model
  # model_in = read_rds(input$model_in$datapath)
  ext <- tools::file_ext(input$modelFile$datapath)
    
    switch(ext,
           "rds" = read_rds(input$modelFile$datapath),  # R models
           "model" = xgb.load(input$modelFile$datapath),  # XGBoost model
           stop("Unsupported file type")
    )
  
  return(model_in)
})

df <- reactive({
  df <- read_csv(input$file1$datapath, col_types = cols(.default = col_number()))
  # df <- read_csv("input/data.csv", col_types = cols(.default = col_number()))
  continuous_columns <- c(1, ncol(df))
  df[, continuous_columns] <- apply(df[, continuous_columns], 2, as.numeric)
  return(df)
})

output$step2 = renderUI({
  req(input$file1)
  h4("Upload knowledge file:")
})

output$ui_file2 = renderUI({
  req(input$file1)
  fileInput("file2", "", accept = ".csv")
})

knowledge <- reactive({
  return(read_csv(input$file2$datapath, col_names = T))
  # knowledge <- read_csv("input/knowledge.csv", col_names = T)
})

output$step3 = renderUI({
  req(graph_complete())
  tagList(
    hr(),
    h4("Step 2: Select your variables of interest:")
  )
})

output$xvar = renderUI({
  req(graph_complete())  
  selectInput('xvar', 'Experimental (X) variable:', c("", names(df())),
              selected = ""
              )
  # xvar = "scenario_main_base"
  # xvar = "humidity"
})

output$yvar = renderUI({
  req(input$xvar)  
  choices <- df() |> select(-input$xvar) |> names()
  selectInput('yvar', 'Outcome (Y) variable:', c("",choices), 
              selected = ""
              )
  # yvar = "images_acquired"
})


output$ui_threshold_x = renderUI({
  req(input$xvar)
  slider_range <- c(min(df()[[input$xvar]]), max(df()[[input$xvar]]))
  slider_step <- (slider_range[2] - slider_range[1]) / 10
   # Use Flexbox for inline alignment
    tags$div(
      style = "display: flex; align-items: center; flex-wrap: wrap;",
      
      # Part 1: Variable Selection
      tags$span(""),
      tags$span("is considered treated when it is "),
      
      # Part 2: Operator Selection
      tags$div(
        style = "margin-right: 5px;",
        selectInput("tv_dir", NULL, 
                    choices = c(">", ">=", "<", "<=", "="), 
                    width = "60px")
        ),
      # Part 3: Threshold Input
      tags$div(
        style = "margin-right: 5px;",
        numericInput("tv_threshold", NULL, 
                     value = mean(slider_range), 
                     step = slider_step,
                     width = "80px")
        )
    )
    # tv_dir = "<="
    # tv_threshold = 0
})

output$ui_threshold_y = renderUI({
  req(input$yvar)
  slider_range <- c(min(df()[[input$yvar]]), max(df()[[input$yvar]]))
  slider_step <- (slider_range[2] - slider_range[1]) / 10
   # Use Flexbox for inline alignment
    tags$div(
      style = "display: flex; align-items: center; flex-wrap: wrap;",
      
      # Part 1: Variable Selection
      tags$span(""),
      tags$span("is considered a success when it is "),
      
      # Part 2: Operator Selection
      tags$div(
        style = "margin-right: 5px;",
        selectInput("ov_dir", NULL, 
                    choices = c(">", ">=", "<", "<=", "="), 
                    width = "60px")
        ),
      # Part 3: Threshold Input
      tags$div(
        style = "margin-right: 5px;",
        numericInput("ov_threshold", NULL, 
                     value = mean(slider_range), 
                     step = slider_step,
                     width = "80px")
        )
    )
    # ov_dir = "<="
    # ov_threshold = 0
})

output$blankGraph <- renderGrViz({
  req(graph_complete())
  dot <- readLines("dotfile.txt")  
  if (graph_update()) {
    dot <- change_node_color(dot, input$xvar, "yellow")
    dot <- change_node_color(dot, input$yvar, "yellow")
    dot <- change_node_color(dot, Zvars[Zvars$grp == "Z1",]$Z, "gray30")
    dot <- change_node_color(dot, Zvars[Zvars$grp == "Z2",]$Z, "gray80")
  }
  grViz(dot)
})

output$histogram_x <- renderPlot({
    req(input$xvar, input$tv_dir, input$tv_threshold)
    data <- df()[[input$xvar]]
    
    # Ensure the selected variable is numeric
    # validate(
    #   need(is.numeric(data), "Selected variable must be numeric.")
    # )
    
    # Define treatment condition based on operator and threshold
    if (input$tv_dir == ">") {
      treated <- data > input$tv_threshold
      treated_label <- paste0("Treated (>", input$tv_threshold, ")")
      untreated_label <- paste0("Untreated (≤ ", input$tv_threshold, ")")
    } else if (input$tv_dir == "<") {
      treated <- data < input$tv_threshold
      treated_label <- paste0("Treated (<", input$tv_threshold, ")")
      untreated_label <- paste0("Untreated (≥ ", input$tv_threshold, ")")
    } else if (input$tv_dir == ">=") {
      treated <- data >= input$tv_threshold
      treated_label <- paste0("Treated (>=", input$tv_threshold, ")")
      untreated_label <- paste0("Untreated (> ", input$tv_threshold, ")")
    } else if (input$tv_dir == "<=") {
      treated <- data < input$tv_threshold
      treated_label <- paste0("Treated (<=", input$tv_threshold, ")")
      untreated_label <- paste0("Untreated (> ", input$tv_threshold, ")")
    } else if (input$tv_dir == "=") {
      treated <- data == input$tv_threshold
      treated_label <- paste0("Treated (= ", input$tv_threshold, ")")
      untreated_label <- "Untreated (≠)"
    }
    
    # Create a dataframe for plotting
    plot_df <- data.frame(
      x = data,
      Treatment = ifelse(treated, "Treated", "Untreated")
    )
    
    # Define colors
    colors <- c("Treated" = "red", "Untreated" = "gray")
    
    # Generate the histogram
    ggplot(plot_df, aes(x = x, fill = Treatment, color = Treatment)) +
      geom_rug(sides = "b") +
      geom_histogram(binwidth = (max(data) - min(data)) / 30, color = "black", alpha = 0.7) +
      scale_fill_manual(values = colors, labels = c(untreated_label, treated_label)) +
      scale_color_manual(values = colors, labels = c(untreated_label, treated_label)) +
      geom_vline(xintercept = input$tv_threshold, color = "gray20", linetype = "dashed", linewidth = 1) +
      labs(
        title = paste("Distribution of ", input$xvar),
        x = NULL,
        # y = "Count",
        fill = "Treatment Status"
      ) +
      guides(color = "none") +  
      theme_minimal()
  })

output$histogram_y <- renderPlot({
    req(input$yvar, input$ov_dir, input$ov_threshold)
    data <- df()[[input$yvar]]
    
    # Ensure the selected variable is numeric
    # validate(
    #   need(is.numeric(data), "Selected variable must be numeric.")
    # )
    
    # Define treatment condition based on operator and threshold
    if (input$ov_dir == ">") {
      success <- data > input$ov_threshold
      success_label <- paste0("Success (>", input$ov_threshold, ")")
      fail_label <- paste0("Fail (≤ ", input$ov_threshold, ")")
    } else if (input$ov_dir == "<") {
      success <- data < input$ov_threshold
      success_label <- paste0("Success (<", input$ov_threshold, ")")
      fail_label <- paste0("Fail (≥ ", input$ov_threshold, ")")
    } else if (input$ov_dir == ">=") {
      success <- data >= input$ov_threshold
      success_label <- paste0("Success (>=", input$ov_threshold, ")")
      fail_label <- paste0("Fail (> ", input$ov_threshold, ")")
    } else if (input$ov_dir == "<=") {
      success <- data < input$ov_threshold
      success_label <- paste0("Success (<=", input$ov_threshold, ")")
      fail_label <- paste0("Fail (> ", input$ov_threshold, ")")
    } else if (input$ov_dir == "=") {
      success <- data == input$ov_threshold
      success_label <- paste0("Success (= ", input$ov_threshold, ")")
      fail_label <- "Fail (≠)"
    }
    
    # Create a dataframe for plotting
    plot_df <- data.frame(
      x = data,
      success = ifelse(success, "Success", "Fail")
    )
    
    # Define colors
    colors <- c("Success" = "red", "Fail" = "gray")
    
    # Generate the histogram
    ggplot(plot_df, aes(x = x, fill = success, color = success)) +
      geom_rug(sides = "b") +
      geom_histogram(binwidth = (max(data) - min(data)) / 30, color = "black", alpha = 0.7) +
      scale_fill_manual(values = colors, labels = c(fail_label, success_label)) +
      scale_color_manual(values = colors, labels = c(fail_label, success_label)) +
      geom_vline(xintercept = input$ov_threshold, color = "gray20", linetype = "dashed", linewidth = 1) +
      labs(
        title = paste("Distribution of ", input$yvar),
        x = NULL,
        # y = "Count",
        fill = "Treatment Status"
      ) +
      guides(color = "none") +  
      theme_minimal()
  })

# output$ui_fillerOutput = renderUI({
#   
# })

output$ui_model_exist = renderUI({
  req(graph_update())
  radioGroupButtons(
    inputId = "model_exist",
    label = "Do you have an existing model?",
    choiceNames = c("Yes: I can upload it", "Yes: I can provide an ATE", "No: Do it all for me"),
    choiceValues = c("Yes", "ATE", "No"), 
    selected = "ATE",
    individual = TRUE,
    checkIcon = list(
      yes = tags$i(class = "fa fa-circle", 
                   style = "color: steelblue"),
      no = tags$i(class = "fa fa-circle-o", 
                  style = "color: steelblue"))
  )
})

output$ui_ate_upload = renderUI({
  req(graph_update())
  if (input$model_exist == "ATE") {
    numericInput("ate_in", label = "ATE: ", value = 0, min = -1, max = 1, step = 0.1)
    # model_exist <- "ATE"
    # ate_in <- 0
  } else (return(NULL))
})

output$ui_model_upload = renderUI({
  req(input$model_exist)
  if (input$model_exist == "Yes") {
    fileInput("model_in", "", 
              accept = c(".rds", ".rda", ".model"))
  } else (return(NULL))
})

output$step4 = renderUI({
  req(graph_update())
  tagList(
    hr(),
    h4("Step 3: Tell us about your model:")
  )
})


output$ui_graphViz = renderUI({
  req(calc_complete())  
  h4("Causal graph")
  grVizOutput("graphViz")
})

output$ui_ci_plot = renderUI({
  req(calc_complete())  
  h4("Comparison of ATE for AIR and ML")
  plotOutput("ci_plot")
})

output$ui_ribbon_plot = renderUI({
  req(calc_complete())  
  h4("Comparison of ATE for AIR and ML")
  imageOutput("ribbon_plot")
})

output$ui_figurecaption = renderUI({
  req(calc_complete())
  uiOutput("figurecaption")
})

output$ui_goButton = renderUI({
  req(graph_update())
  actionBttn(
    inputId = "goButton",
    label = "Calculate Results",
    style = "unite", 
    color = "primary"
  )
})

output$ui_buildButton = renderUI({
  req(input$file2)
  actionBttn(
    inputId = "buildButton",
    label = "Build Graph",
    style = "unite", 
    color = "primary"
    )
})

output$ui_updateButton = renderUI({
  req(input$yvar)
  actionBttn(
    inputId = "updateButton",
    label = "Update Graph",
    style = "unite",
    color = "primary"
    )
})

observeEvent(input$updateButton, {
  # assign global variables
  assign("df_vars",
         data.frame("var" = c("TV","OV"),
                    "val" = c(input$xvar, input$yvar)),
         envir = .GlobalEnv)
  # assign("df_vars", data.frame("var" = c("TV","OV"), "val" = c(xvar, yvar)), envir = .GlobalEnv)
  # source_python(paste0(AIRHome, "/scripts/identify.py"))
  if (Sys.info()["sysname"] == "Linux") {
    param1 = df_vars$val[1]
    param2 = df_vars$val[2]
    
    rust_bin = paste0(AIRHome, "/scripts/identify")
    # system2() returns the output as a character vector (one element per line).
    json_output <- system2(rust_bin,
                           args = c(paste0("--param1=", param1),
                                    paste0("--param2=", param2)),
                           stdout = TRUE)
    
    # json_output is a character vector. If the Rust program only prints a single line
    # of JSON, json_output[1] will hold the entire JSON string.
    parsed <- fromJSON(json_output[1])
    
    # Now `parsed` should be a list with two elements: $vector1 and $vector2
    Z1 <- parsed$vector1
    Z2 <- parsed$vector2
  } else {
    source("scripts/identify.R")
  }
  Z1 = strsplit(gsub("(\\}|\\{|\\')","",toString(Z1), perl = T), ", ")[[1]]
  Z2 = strsplit(gsub("(\\}|\\{|\\')","",toString(Z2), perl = T), ", ")[[1]]
  # Z1 = "region_sensitivity"
  # Z2 = "mission_urgency"
  ### overlaps in function with df_vars. consider combining and slimming down. consider appending to df_vars ---------
  Zvars_loc <- data.frame("name" = character(),
                          "grp" = character(),
                          "Z" = character())

  for (i in Z1) {
    Zvars_loc <- rbind(Zvars_loc, c(df_vars[df_vars$var == "TV",]$val, "Z1", i))
  }

  for (i in Z2) {
    Zvars_loc <- rbind(Zvars_loc, c(df_vars[df_vars$var == "TV",]$val, "Z2", i))
  }

  colnames(Zvars_loc) <- c("name", "grp", "Z")
  assign("Zvars", Zvars_loc, envir = .GlobalEnv)

  graph_update(TRUE)

  # updatte the graph
  output$blankGraph <- renderGrViz({
  req(graph_complete())
  dot <- readLines("dotfile.txt")  
  if (graph_update()) {
    dot <- change_node_color(dot, input$xvar, "yellow")
    dot <- change_node_color(dot, input$yvar, "yellow")
    dot <- change_node_color(dot, Zvars[Zvars$grp == "Z1",]$Z, "gray30")
    dot <- change_node_color(dot, Zvars[Zvars$grp == "Z2",]$Z, "gray80")
  }
  grViz(dot)
  })

})

observeEvent(input$buildButton, {
  ### AIR Step 1 ----------------
  if (Sys.info()["sysname"] == "Linux") {
    graph <- AIR_getGraph(df(), knowledge()) # prod
    dot <- .jcall("edu/cmu/tetrad/graph/GraphSaveLoadUtils", "Ljava/lang/String;", "graphToDot", graph) # prod
  } else {
    graph <- read_file("graphtxt.txt") # test
    dot <- read_file("dotfile.txt") # test
  }
  # graph <- AIR_getGraph(df, knowledge)
  
  # graph_data <- .jcall(graph, "Ljava/lang/String;", "toString")
  # writeLines(graph_data, "graphtxt.txt")

  # Visualize the resulting graph
  # visualize_graph(graph)
  write(dot, "dotfile.txt")
  graph_complete(TRUE)
  
  output$blankGraph <- renderGrViz({
  req(graph_complete())
  dot <- readLines("dotfile.txt")  
  grViz(dot)
  })
})
  
observeEvent(input$goButton, {
    withProgress(message = 'Building Causal Graph', style = "notification", value = 0.1, {

    incProgress(0.1, message = "Calculating Adjustment Sets")


    ### AIR Step 3 ----------------
    
    write_csv(df(), paste0(AIRHome, "/data/datafile.csv"), col_names = T)

    incProgress(0.1, message = "Estimating Causal Effects")
    assign("model_yn",
           input$model_exist,
           envir = .GlobalEnv)

    assign("model_ate",
           input$ate_in,
           envir = .GlobalEnv)

    # assign("model_yn", model_exist, envir = .GlobalEnv)
    # assign("model_ate", ate_in, envir = .GlobalEnv)

    write.csv(file = "Results.csv",
              x = data.frame("Row" = vector(),
                             "Treatment" = vector(),
                             "Group" = vector(),
                             "Mean" = vector(),
                             "LCI" = vector(),
                             "UCI" = vector()),
              row.names = FALSE)
    
    if (Sys.info()["sysname"] == "Linux") {
      Sys.chmod("Results.csv", mode = "0777")
    }
    
    for (i in unique(Zvars$name)) {
      for (j in unique(Zvars$grp)) {
        settings <- data.frame(doc_title = paste0(i,"-",j),
                                  nfold = 20,
                                  Z_level = j,
                                  varName = i,
                                  confounders = paste0(Zvars[Zvars$name == i & Zvars$grp == j,]$Z, collapse = " "))
        tryCatch({
          incProgress(0.3, detail = paste0("\nCalculating ATE for ",j," Adjustment Set"))
          }, error = function(e) {
            NULL
            })
        runSuperLearner(settings, AIRHome, input$tv_dir, input$tv_threshold, input$ov_dir, input$ov_threshold)
        # runSuperLearner(settings, AIRHome, tv_dir, tv_threshold, ov_dir, ov_threshold)
      }
    }
    
    incProgress(0.2, message = "Processing Results")
    processResults(settings, AIRHome, input$tv_dir, input$tv_threshold, input$ov_dir, input$ov_threshold, model_in())
    # processResults(settings, AIRHome, tv_dir, tv_threshold, ov_dir, ov_threshold, model_in)
    
    
    calc_complete(TRUE)
  })
})

output$graphViz = renderGrViz({
  req(calc_complete())
  
  dot <- read_file("dotfile.txt")
  dot <- change_node_color(dot, input$xvar, "yellow")
  dot <- change_node_color(dot, input$yvar, "yellow")
  # dot <- change_node_color(dot, xvar, "yellow")
  # dot <- change_node_color(dot, yvar, "yellow")

  dfr <- read_csv(paste0(AIRHome, "/data/ResultsOut.csv"))
  Z1 <- Zvars[Zvars$grp == "Z1",]$Z
  Z2 <- Zvars[Zvars$grp == "Z2",]$Z

  # code for generating ribbon plot
  if (any(dfr$flag > dfr$z1_ATE_UCI & dfr$flag < dfr$z2_ATE_UCI)) {
    dot <- change_node_color(dot, Z2, "'#FCB514'")
  } else if (any(dfr$flag > dfr$z1_ATE_LCI & dfr$flag < dfr$z2_ATE_LCI)) {
    dot <- change_node_color(dot, Z1, "'#FCB514'")
  } else if (any(dfr$flag > dfr$z1_ATE_UCI & dfr$flag > dfr$z2_ATE_UCI)) {
    dot <- change_node_color(dot, Z1, "'#C00000'")
    dot <- change_node_color(dot, Z2, "'#C00000'")
  } else if (any(dfr$flag < dfr$z1_ATE_UCI & dfr$flag < dfr$z2_ATE_UCI)) {
    dot <- change_node_color(dot, Z1, "'#C00000'")
    dot <- change_node_color(dot, Z2, "'#C00000'")
  } 

  grViz(dot)
})
  

# output$ribbon_plot = renderImage({
output$ribbon_plot = renderPlot({
  req(calc_complete())  
  dfr <- read_csv(paste0(AIRHome, "/data/ResultsOut.csv"))

  # code for generating ribbon plot
  if (any(dfr$flag >= dfr$z1_ATE_LCI & dfr$flag <= dfr$z1_ATE_UCI)) {
    inZ1 <- TRUE
  } else { inZ1 <- FALSE }
  if (any(dfr$flag >= dfr$z2_ATE_LCI & dfr$flag <= dfr$z2_ATE_UCI)) {
    inZ2 <- TRUE
  } else { inZ2 <- FALSE }
  
  summary_color <- case_when(
    inZ1 == TRUE & inZ2 == TRUE ~ "#378855",
    inZ1 == TRUE | inZ2 == TRUE ~ "#FCB514",
    inZ1 == FALSE & inZ2 == FALSE ~ "#C00000"
  )

  dfr0 <- dfr[1,]
  p <- ggplot(dfr0, aes(x = Treatment)) +
  # ggplot(dfr0, aes(x = Treatment)) +
    ## background
    geom_linerange(aes(ymin = -1.05, ymax = 1.05),
                   lwd = 6,
                   col = "black",
                   alpha = 1,
                   stat = "unique",
                   lineend = "round",
                   position = position_nudge(x = 0)) +
    ## Annotations for '-' and '+'
    # annotate("text", x = 0.92, y = -1.07, label = "-", hjust = 0, vjust = 0, size = 5, color = "white") +
    # annotate("text", x = 0.88, y = 1.025,  label = "+", hjust = 0, vjust = 0, size = 5, color = "white") +
    annotate("text", 
             x = 1,  # Position on the left side within the black background
             y = -1,  # Center vertically within the black background
             label = "-", 
             hjust = 2.5, 
             vjust = 0.25, 
             size = 5, 
             color = "white") +
    annotate("text", 
             x = 1,  # Position on the right side within the black background (adjust based on x-axis limits)
             y = 1,  # Center vertically within the black background
             label = "+", 
             hjust = -0.75, 
             vjust = 0.4, 
             size = 5, 
             color = "white") +## algorithm estimates
    ## Z1
    geom_linerange(aes(ymin = z1_ATE_LCI, ymax = z1_ATE_UCI),
                   lwd = 3.5,
                   col = "#292929",
                   alpha = 1,
                   stat = "unique",
                   lineend = "round",
                   position = position_nudge(x = 1)) +
    geom_point(aes(y = z1_ATE),
               col = "white",
               cex = 3,
               pch = 1,
               stroke = 1.25,
               position = position_nudge(x = 1)) +
    ## Z2
    geom_linerange(aes(ymin = z2_ATE_LCI, ymax = z2_ATE_UCI),
                   lwd = 3.5,
                   col = "#777777",
                   alpha = 1,
                   stat = "unique",
                   lineend = "round",
                   position = position_nudge(x = 0.5)) +
    geom_point(aes(y = z2_ATE),
               col = "white",
               cex = 3,
               pch = 1,
               stroke = 1.25,
               position = position_nudge(x = 0.5)) +
    # creating the ribbon
    geom_linerange(aes(ymin = -1, ymax = 1),
                   lwd = 3.5,
                   col = "#C00000",
                   alpha = 1,
                   stat = "unique",
                   lineend = "round",
                   position = position_nudge(x = 0)) +
    geom_linerange(aes(ymin = min(dfr$z1_ATE_LCI, dfr$z2_ATE_LCI), ymax = max(dfr$z1_ATE_UCI, dfr$z2_ATE_UCI)),
                   lwd = 3.5,
                   col = "#FCB514",
                   alpha = 1,
                   stat = "unique",
                   lineend = "round",
                   position = position_nudge(x = 0)) +
    geom_linerange(aes(ymin = max(dfr$z1_ATE_LCI, dfr$z2_ATE_LCI), ymax = min(dfr$z1_ATE_UCI, dfr$z2_ATE_UCI)),
                   lwd = 3.5,
                   col = "#378855",
                   alpha = 1,
                   stat = "unique",
                   lineend = "round",
                   position = position_nudge(x = 0)) +
    geom_segment(aes(x = 0.6, xend = 1.35, y = 0, yend = 0), lwd = 1.2) +
    ## algorithm estimates
    labs(y = "",
         x = "") +
    geom_segment(data = dfr,
                 aes(x = 2.5, xend = 1.25, y = flag, yend = flag, color = algorithm),
                 arrow = arrow(length = unit(0.5, "cm")),
                 lwd = 1.2,
                 color = "#0F9ED5") +
    geom_point(data = dfr,
               aes(x = 2.5, y = flag, shape = algorithm),
               size = 3,  # Adjust size as needed
               color = "#0F9ED5") +  # Or any desired color
    coord_flip(clip = "off") +
    ## Adjust Scales to Remove Expansion and Compress Vertically
    scale_x_discrete(expand = c(0, 0)) +
    scale_y_continuous(expand = c(0, 0),
                       limits = c(-1.1, 1.1)) +  # Tighten y-axis limits
    ## Theme Adjustments to Minimize White Space
    theme_void(base_size = 10) +
    # theme(
    #   # panel.spacing = unit(0, "pt"),
    #   panel.background = element_rect(fill = "transparent", color = NA),
    #   plot.background = element_rect(fill = "transparent", color = NA),
    #   aspect.ratio = 0.2
    # )
    theme(
      panel.background = element_rect(fill = "transparent", color = NA),
      plot.background = element_rect(fill = "transparent", color = NA),
      aspect.ratio = 0.2
    )
  
  p  
})

output$figurecaption = renderUI({
  req(calc_complete())
  caption <- paste0("Risk Difference: This chart represents the difference in outcomes resulting from a change in your experimental variable,",df_vars[1,][[2]],". The x-axis ranges from negative to positive effect, where the treatment, ", df_vars[2,][[2]]," either increases the likelihood of the outcome or decreases it, respectively. The midpoint corresponds to 'no significant effect.")
  tags$div(style = "font-size:12px;", caption)

  })

output$ui_interpretation = renderUI({
  req(calc_complete())  

  dfr <- read_csv(paste0(AIRHome, "/data/ResultsOut.csv"))

  interpretation <- "What we can learn from these results"
  dfr$zmax <- max(dfr$z1_ATE_UCI, dfr$z2_ATE_UCI)
  dfr$zmin <- min(dfr$z1_ATE_LCI, dfr$z2_ATE_LCI)
  
  if ((all(dfr$z1_ATE_UCI < dfr$z2_ATE) & all(dfr$z2_ATE_LCI > dfr$z1_ATE)) |
      (all(dfr$z1_ATE_LCI > dfr$z2_ATE) & all(dfr$z2_ATE_UCI < dfr$z1_ATE))) {
    interpretation <- "Inconsistent Causal ATE suggests not enough information to properly train a model."
  } else if (all(dfr$flag > dfr$zmin & dfr$flag < dfr$zmax)) {
    interpretation <- "Classifier Predictions match Causally-Derived ATE estimates. Your Classifier is healthy!"
  } else if (all(dfr$flag > dfr$zmax) | all(dfr$flag < dfr$zmin)) {
    interpretation <- "Classifier Predictions do not match Causally-Derived ATE estimates. Your Classifier is to be considered unreliable. Consider looking into why this might be."
  } else {
    interpretation <- "Classifier Predictions are mixed with respect to Causally-Derived ATE estimates. Use with caution and consider looking into why."
  }
  
  
  if (any(between(dfr$flag, dfr$z1_ATE_LCI[1], dfr$z1_ATE_UCI[1]))) {
    inZ1 <- TRUE
  } else { inZ1 <- FALSE }
  if (any(between(dfr$flag, dfr$z2_ATE_LCI[1], dfr$z2_ATE_UCI[1]))) {
    inZ2 <- TRUE
  } else { inZ2 <- FALSE }
  
  maxflag <- max(dfr$z1_ATE_LCI, dfr$z1_ATE_UCI, dfr$z2_ATE_LCI, dfr$z2_ATE_UCI)
  minflag <- min(dfr$z1_ATE_LCI, dfr$z1_ATE_UCI, dfr$z2_ATE_LCI, dfr$z2_ATE_UCI)
  flagdir <- case_when(maxflag < 0 ~ "a negative",
                       minflag > 0 ~ "a positive",
                       TRUE ~ "no")
  effect_estimation <- case_when(any(abs(dfr$flag) < min(abs(maxflag), abs(minflag))) ~ "underestimating",
                                 any(abs(dfr$flag) > max(abs(maxflag), abs(minflag))) ~ "overestimating",
                                 TRUE ~ "correctly estimating")
  effect_percent <- case_when(effect_es:timation == "underestimating" ~ paste0(" by ", round(abs(maxflag) - abs(mean(dfr$flag)), 2)*100, "-",round(abs(minflag) - abs(mean(dfr$flag)), 2)*100, "%"),
                          effect_estimation == "overestimating" ~ paste0(" by ", round(abs(mean(dfr$flag)) - abs(minflag), 2)*100, "-",round(abs(mean(dfr$flag)) - abs(maxflag), 2)*100, "%"),
                          TRUE ~ "")
  effect_fortune <- case_when(inZ1 & inZ2 ~ "Fortunately",
                              TRUE ~ "Unfortunately")
  
  result_text <- paste0("Your classifier is ",
         effect_estimation, 
         " the effect that ", 
         df_vars[1,][[2]], 
         " is having on ", 
         df_vars[2,][[2]], 
         effect_percent, 
         ". AIR predicts that ", 
         df_vars[1,][[2]], 
         " should be having ", 
         flagdir, 
         " effect on ", 
         df_vars[2,][[2]],
         ". As ", 
         df_vars[1,][[2]], 
         " changes, the outcome of ", 
         df_vars[2,][[2]], 
         " is ", 
         case_when(flagdir == "a negative" ~ paste0("between ", round(min(abs(minflag),abs(maxflag)), 2)*100,"-",round(max(abs(minflag),abs(maxflag)), 2)*100,"% less likely to occur. "),
                   flagdir == "a positive" ~ paste0("between ", round(min(abs(minflag),abs(maxflag)), 2)*100,"-",round(max(abs(minflag),abs(maxflag)), 2)*100,"% more likely to occur. "),
                   TRUE ~ "unlikely to change. "),
         effect_fortune,
         ", your classifier is producing ",
         case_when(inZ1 & inZ2 ~ "un",
                   inZ1 | inZ2 ~ "potentially-",
                   TRUE ~ ""),
         "biased results, suggesting ",
         case_when(effect_estimation == "underestimating" ~ "a decreased ",
                   effect_estimation == "overestimating" ~ "an increased ",
                   TRUE ~ "an appropriate "),
         "change in likelihood of ", 
         df_vars[2,][[2]],
         " as ",
         df_vars[1,][[2]],
         " changes. ",
         case_when(inZ1 & inZ2 ~ "No bias is detected at this time.",
                   inZ1 == TRUE & inZ2 == FALSE ~ paste0("Bias is likely being introduced into the training process at variable(s): ", paste0(Z2, collapse = ", "), " (see graph)."),
                   inZ2 == TRUE & inZ1 == FALSE ~ paste0("Bias is likely being introduced into the training process at variable(s): ", paste0(Z1, collapse = ", "), " (see graph)."),
                   TRUE ~ paste0("Bias is likely being introduced into the training process at variable(s): ", paste0(Z1, collapse = ", "), " and/or ", paste0(Z2, collapse = ", ")," (see graph)."))
         )

  tagList(
    tags$h3("Interpreting your results:"),
    tags$div(style = "font-size:24px;", result_text)
  )
})

output$second_column_content <- renderUI({
    tags$div(
      style = "display: flex; flex-direction: column; height: 100%;",
      tags$div(
        style = "flex: 0 0 25%;",
        uiOutput("ui_ribbon_plot")
      ),
      tags$div(
        style = "flex: 0 0 25%;",
        uiOutput("ui_figurecaption")
      ),
      tags$hr(
        style = "border: none; border-top: 1px solid #ccc; margin: 5px 0;"
      ),
      tags$div(
        style = "flex: 1;",
        uiOutput("ui_interpretation")
      )
    )
  })
```
